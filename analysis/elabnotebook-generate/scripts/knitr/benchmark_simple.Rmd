Date: `r date()` <br/>
Analysis version ([challprop-analytics](https://bitbucket.org/gbi/challprop-analytics)): {analysis_commitNo} <br/>
(use `git checkout $commit$` if needed) 

```{r accumulate-data, engine='groovy', echo=FALSE}
import java.io.File
import groovy.util.ConfigSlurper

//list of all experiments (commit numbers):
experiments = [
'64d12b4868b8bdbc5ab3cd7c5055988c4f15102b',
'2614e5751b257f710fee8de0a0041e824c09c0a8',
'57133cc8615aee344820d0b289b523fdc54b1c09',
'07aab72e537e28ae0cf63f9067ef3bcb3df2265c',
'a5d2385359537736fa21b312470042dcdcadbdce',
'95fd1772a554ef98be0c9fb54bbbbf75fd8088db',
'aafb8e534a011bf6bdae5fc13c08886b98057b50',
'b713ce78ea2e40e8a8239f95e68ec1c5ae8269dc',
'f8adcaf83dc6afdd803e578b2baa38c69d3cde11',
'e0e987190667cd30915fb160fe9f5b1f67a07c80',
'3eade203e073b124896f0d34b03cc336fdde17c1',
'ce603975b7df039cc394ff5b74f0d06542acae7c',
'6dbf55d153c45244dbd9da2e031cb6ab78a949ee',
'aafeee1801074bfb0a0f6ecc09b06fe0c0589382',
'7209550ba060652773a97464ee60e25129485040',
'79ca2934bdb75bac3b0901c6a8fb3df9784d57b6',
'a30b2e675d1e26d8e4184b2fa58a5add1976193c',
'6f82a3c9f05e90833a085a80a1dfd50301cb94cd',
'ddc5870516c582e9df6e635d937f40bafdbafcc5',
'6e0899ade7a9245c9168b22ee97cc63d4b7a11e9',
'f4ead156ed14acc92d4620ed70f911a4ec3395c2'
]

//open a temp file for collecting all the data into one place:
File propertiesAll = new File("/media/data/gbi/eln/other_experiments/benchmarking/challprop-java.txt")
propertiesAll.delete()
propertiesAll.createNewFile()

experiments.each {commitNo->
  params = new ConfigSlurper().parse(new File("../../data/"+commitNo+"/parameters.conf").toURL())
	simulationStartWallSec = params.properties.simulationStartWall * 1.0E-9
	simulationFinishWallSec = params.properties.simulationFinishWall * 1.0E-9
  simulationStartCPUSec = params.properties.simulationStartCPU * 1.0E-9
	simulationFinishCPUSec = params.properties.simulationFinishCPU * 1.0E-9
  propertiesAll << ("${params.properties.numberOfAgents},${simulationStartWallSec},${simulationFinishWallSec},${simulationStartCPUSec},${simulationFinishCPUSec}\n")
}
```

```{r init, echo=FALSE}
matlab.df <- read.table(file='/media/data/gbi/eln/other_experiments/benchmarking/matlab/times.txt',header=F,sep=',')
matlab.df <- matlab.df[with(matlab.df, order(V1)), ]
java.df <- read.table(file='/media/data/gbi/eln/other_experiments/benchmarking/challprop-java.txt',header=F,sep=',')
java.df <- java.df[with(java.df, order(V1)), ]
matlab.df$secsOfSimulationCPU = matlab.df$V3 - matlab.df$V2
matlab.df$secsOfSimulationWall = matlab.df$V5
java.df$secsOfSimulationWall = java.df$V3 - java.df$V2
java.df$secsOfSimulationCPU = java.df$V5 - java.df$V4
matlab.df$secsPerAgentWall = matlab.df$secsOfSimulationWall / matlab.df$V1
matlab.df$secsPerAgentCPU = matlab.df$secsOfSimulationCPU / matlab.df$V1
java.df$secsPerAgentWall = java.df$secsOfSimulationWall / java.df$V1
java.df$secsPerAgentCPU = java.df$secsOfSimulationCPU / java.df$V1
library(ggplot2)

#getting code version:
conn = file('../../challprop-experiments/code.version',open='r');
linn = readLines(conn);
codeVersion = linn[1];
close(conn);
library(stringr);
```
##Setup

The benchmarking of [chalprop-matlab](https://bitbucket.org/evob/chalprop_matlab) vs [challprop-java](https://bitbucket.org/gbi/challprop/wiki/Home) was performed by running simulations with identical parameters (to the extent different implementations allowed it) and logging running times. I was logging only [CPU time](http://en.wikipedia.org/wiki/CPU_time) and [Wall time](http://en.wikipedia.org/wiki/Wall-clock_time) - I probably had to log memory usage too, because that made quite a difference...

The hardware used:
```
system              SZ68R2 (1.0)
memory(RAM)         16GiB System Memory
processor           Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz
configuration:      cores=4 enabledcores=4 threads=8
disk                2TB ST2000DM001-9YN1
in short:           kinda super-duper (more-or-less)
```

The variable parameter was the number of agents: from 10 to 10,000 with varying step, totally 20 simulations on both engines (see [Results][]; note that chalprop-matlab with 10,000 agents was not finished because out of RAM overflow...).

Main stable parameters across all the simulations:
```
number of generations:              100;
new situations/generation:          20% of number of agents;
components in vector:               10;
no of rival components              50%;
negative components in situations:  20%;
```

Statistics of times spent on simulations in total and per one agent is presented in tables and graphs in [Results] then followed by some [Discussion].

```{r createtotaltable, echo=FALSE}
num <-nrow(matlab.df);
mattemp.df <- data.frame(matrix(ncol = 0, nrow = num));
num <-nrow(java.df);
javtemp.df <- data.frame(matrix(ncol = 0, nrow = num));
mattemp.df$numberOfAgents <- matlab.df$V1;
javtemp.df$numberOfAgents <- java.df$V1;

mattemp.df$secsOfSimulationWallMatlab <-matlab.df$secsOfSimulationWall;
mattemp.df$secsOfSimulationCPUMatlab <-matlab.df$secsOfSimulationCPU;
javtemp.df$secsOfSimulationWallJava <-java.df$secsOfSimulationWall;
javtemp.df$secsOfSimulationCPUJava <-java.df$secsOfSimulationCPU;

library(plyr)
table.df <- merge(mattemp.df, javtemp.df,by="numberOfAgents", all=TRUE,sort=T);
table.df <- rename(table.df, c("numberOfAgents"="number of agents","secsOfSimulationWallMatlab"="wall time - matlab","secsOfSimulationCPUMatlab"="cpu time - matlab", "secsOfSimulationWallJava"="wall time - java", "secsOfSimulationCPUJava"="cpu time - java"));

```
##Results
### Total simulation time:
```{r totaltable, results='asis',echo=FALSE}
library(xtable);
print(xtable(table.df,align='lccccc',caption="time values are in seconds"),type='html',include.rownames=FALSE, NA.string="n.a.");
```

```{r totaltime, echo=FALSE}

totaltime <- ggplot() +
  geom_line(data=matlab.df, aes(x=V1, y=secsOfSimulationWall, color="challprop-matlab wall time")) +
  geom_point(data=matlab.df,aes(x=V1,y=secsOfSimulationWall,color="challprop-matlab wall time"),size=2,style=0)+
  geom_line(data=matlab.df, aes(x=V1, y=secsOfSimulationCPU, color="challprop-matlab CPU time")) +
  geom_point(data=matlab.df,aes(x=V1,y=secsOfSimulationCPU,color="challprop-matlab CPU time"),size=2,style=1)+
  
  geom_line(data=java.df, aes(x=V1, y=secsOfSimulationWall, color="challprop-java wall time")) +
  geom_point(data=java.df,aes(x=V1,y=secsOfSimulationWall,color="challprop-java wall time"),size=2,style=2)+
  geom_line(data=java.df, aes(x=V1, y=secsOfSimulationCPU, color="challprop-java CPU time")) +
  geom_point(data=java.df,aes(x=V1,y=secsOfSimulationCPU,color="challprop-java CPU time"),size=2,style=3)+
  xlab('Number of agents')+
  ylab('Time in seconds')+
  theme(legend.title=element_blank())
totaltime
```

### Simulation time per agent:

```{r createagenttable, echo=FALSE}
num <-nrow(matlab.df);
mattemp.df <- data.frame(matrix(ncol = 0, nrow = num));
num <-nrow(java.df);
javtemp.df <- data.frame(matrix(ncol = 0, nrow = num));
mattemp.df$numberOfAgents <- matlab.df$V1;
javtemp.df$numberOfAgents <- java.df$V1;

mattemp.df$secsPerAgentWallMatlab <-matlab.df$secsPerAgentWall;
mattemp.df$secsPerAgentCPUMatlab <-matlab.df$secsPerAgentCPU;
javtemp.df$secsPerAgentWallJava <-java.df$secsPerAgentWall;
javtemp.df$secsPerAgentCPUJava <-java.df$secsPerAgentCPU;

library(plyr)
table.df <- merge(mattemp.df, javtemp.df,by="numberOfAgents", all=TRUE,sort=T);
table.df <- rename(table.df, c("numberOfAgents"="number of agents","secsPerAgentWallMatlab"="wall time - matlab","secsPerAgentCPUMatlab"="cpu time - matlab", "secsPerAgentWallJava"="wall time - java", "secsPerAgentCPUJava"="cpu time - java"));
```

```{r agenttable, results='asis',echo=FALSE}
library(xtable);
print(xtable(table.df,align='lccccc',caption="time values are in seconds"),type='html',include.rownames=FALSE, NA.string="n.a.");
```

```{r agenttime, echo=FALSE}
agenttime <- ggplot() +
  geom_line(data=matlab.df, aes(x=V1, y=secsPerAgentWall, color="challprop-matlab wall time")) +
  geom_point(data=matlab.df,aes(x=V1,y=secsPerAgentWall,color="challprop-matlab wall time"),size=2,style=0)+
  geom_line(data=matlab.df, aes(x=V1, y=secsPerAgentCPU, color="challprop-matlab CPU time")) +
  geom_point(data=matlab.df,aes(x=V1,y=secsPerAgentCPU,color="challprop-matlab CPU time"),size=2,style=1)+
  geom_line(data=java.df, aes(x=V1, y=secsPerAgentWall, color="challprop-java wall time")) +
  geom_point(data=java.df,aes(x=V1,y=secsPerAgentWall,color="challprop-java wall time"),size=2,style=2)+
  geom_line(data=java.df, aes(x=V1, y=secsPerAgentCPU, color="challprop-java CPU time")) +
  geom_point(data=java.df,aes(x=V1,y=secsPerAgentCPU,color="challprop-java CPU time"),size=2,style=3)+
  xlab('Number of agents')+
  ylab('Time in seconds')+
  theme(legend.title=element_blank())
agenttime
```

##Discussion
First, a techinical note. Both java and matlab simulations were dumping data files at the end of simulation. For larger simulations, saving these files to disk seemed to take quite a large portion of the simulation; this time is not reflected in the statistics above; on the other hand, the issue that was not captured by current benchmarking is the quite a lot of memory needed for manipulating these files. E.g. chalprop-matlab used more than 25GB RAM. Challprop-matlab was a little better with this and used around 4GB (for 6000 agents simulation).

Challprop-java seems to be more efficient from the beginning. What is probably most important is that challprop-java time behavior is closer linear (though still with some multpilier especially at higher numbers of agents) than chalprop-matlab. As noted in the beginning I was not able to run matlab with higher numbers, so the it is not clear how it behaves when numberOfAgents > 5000.

Matlab uses one processor almost 100% of capacity all the time of simulation, therefore CPU time and wall time measures for it are almost identical. Java, on the other hand, behaves differently: CPU time is almost 2 times lower than wall time. What it probably means is that challprop-java is underutilizing CPU because it needs to wait for reads/writes from/to the graph database; this is innefficiency, althought probably contributing to using less memory. It is also an opportunity for improvement.

Final note about the overhead of using a graph database. I am actually not sure what is the exact overhead which needs some more fine-tuned benchmarking. But the reason for using graph database as underlying data structure for challprop-java was mostly motivated by the need to analyze the data coming from simulation in as great detail as possible. At my current understanding recording all the atomic events into the graph database as edges (see [challprop-java wiki](https://bitbucket.org/gbi/challprop/wiki/Home)) is the only way to meet this requirement including the fact that graph databases are specifically tuned for big data analysis. I also believe that the communication between simulation and database can be made more efficient, but this is a topic of another post.

## Code
All code for every simulation and analysis were stored in git repos listed below.

###Challprop-matlab
repo/branch:</br>
`git clone -b vveitas git@bitbucket.org:evob/chalprop_matlab.git`</br>
Version used (=commit hash):</br>
`git checkout 5adc760`</br>

###Challprop-java
repo/branch:</br>
`git clone -b master git@bitbucket.org:gbi/challprop-experiments.git`</br>
Versions used (commit hash--commit message):</br>
```
2614e57--benchmarking with 4000 agents: cputime + walltime
57133cc--benchmarking with 3000 agents: cputime + walltime
8d3377c--benchmarking with 2000 agents: cputime + walltime
a5d2385--benchmarking with 30 agents: cputime + walltime
fecb9bd--benchmarking with 10000 agents: cputime + walltime
13c4918--benchmarking with 5000 agents: cputime + walltime
3742693--benchmarking with 1000 agents: cputime + walltime
0220857--benchmarking with 800 agents: cputime + walltime
9ed6ab6--benchmarking with 600 agents: cputime + walltime
b996638--benchmarking with 400 agents: cputime + walltime
9b20c1e--benchmarking with 200 agents: cputime + walltime
15cf842--benchmarking with 100 agents: cputime + walltime
b10ebe4--benchmarking with 90 agents: cputime + walltime
8f27e55--benchmarking with 80 agents: cputime + walltime
81dc169--benchmarking with 70 agents: cputime + walltime
4aae4c2--benchmarking with 60 agents: cputime + walltime
28b6c8c--benchmarking with 50 agents: cputime + walltime
ea1c2cb--benchmarking with 40 agents: cputime + walltime
6e0899a--benchmarking with 20 agents: cputime + walltime
f4ead15--benchmarking with 10 agents: cputime + walltime
```
Simulation version of java-experiment ([challprop](https://bitbucket.org/gbi/challprop)): `r str_sub(codeVersion,-7,-1)` <br/>
(use `git checkout $commit$` if needed) 
